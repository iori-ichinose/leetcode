# 122. 买卖股票的最佳时机 II

## [原题](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii)

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

## 解题思路与代码实现

### 动态规划

考虑到不限制交易次数，因此对于每一天我们既可以留下之前的股票或者售出手上有的股票。我们新建一个二维数组`dp`，其中`dp[i][0]`表示第i天交易完后若手上没有股票时的最大利润，`dp[i][0]`表示当天交易完手上有股票时的最大利润。对于`dp[i][0]`，一种情况是前一天本来手上也没有股票，当天也没买入；另一种情况是前一天有股票，当天卖出了。我们需要选择二者中的较大者即可。类似的，对于`dp[i][1]`，一种情况是前一天手上有股票，但当天没卖出；另一种情况是前一天手上没有股票，当天买入了，同样我们选择较大的作为值。因此能得到以下状态转移方程。

$$
\begin{cases}
    dp[i][0] = max{dp[i - 1][0], dp[i - 1][1] + prices[i]}\\
    dp[i][1] = max{dp[i - 1][1], dp[i - 1][0] - prices[i]}
\end{cases}
$$

初始时，如果第一天不买入，则收益为`0`；如果买入，则收益为`-prices[0]`，因此有`dp[0][0] = 0, dp[0][1] = -prices[0]`。最后一天时，手上持有股票的收益必然小于卖出的收益，所以最后结果是`dp[n - 1][0]`

```C++
class Solution {
  public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int dp[n][2];
        dp[0][0] = 0, dp[0][1] = -prices[0];
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
};
```

### 贪心算法

